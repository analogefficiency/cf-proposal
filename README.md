# cf-proposal
Sample URL Shortener Service

# Minimum Viable Product
- [X] POST Endpoint taking in a LONG URL returning a SHORT URL
- [X] GET Endpoint that redirects short urls to the requested long URL
- [X] GET Endpoint returning access statistics for each short URL (24 hours, past week, all time)
- [ ] Short URLS can expire or live forever
- [X] Data survives restarts
- [X] DELETE Endpoint allowing a short URL to be deleted
- [X] Runnable locally with simple instructions
- [X] Documentation includes build and deploy instructions
- [ ] Tests able to be executed locally OR within a test environment 

# API
**Redirect short url to a long url**
```
       Path: /{shortUrl}
     Method: GET
Description: Redirects request to perform GET request of URL associated with the path parameter, shortUrl
 Parameters: @pathparameter - shortUrl: Hashed version of the long url assocated with the short url
```
**Creating a short url**
```
       Path: /url/create
     Method: POST
Description: Creates short url based on values provided in request body
 Parameters: @json { LongUrl: String, AccessDt: String }
    Returns: @json { UrlId: int32, LongUrl: String, ShortUrl: String, AccessDt: String }
```
**Deleting a short url**

```
       Path: /url/delete/{id}
     Method: DELETE
Description: Deletes short url based on id provided in path parameters
 Parameters: @pathparamter - id: The id for the short url
```
**Getting statistics for a short url**

```
       Path: /statistics/{id}
     Method: GET
Description: Retrives statistics for a given short url id. Returns usage of short url within last 24 hours, 7 days, and all time. 
 Parameters: @pathparameter - id: The id for the short url
    Returns: @json { UrlId: int32, TwentyFourHours: int32, LastSevenDays: int32, AllTime: int32 }
```


# Build Information
ðŸš¨ These instuctions are based on a OSX workstation using [homebrew](https://brew.sh/). 

Clone the repo at your preferred workspace location

`git clone https://github.com/analogefficiency/cf-proposal.git`

This project will be using `Docker` to build and run the application. Docker can be installed via the following command:

`brew install --cask docker`

From the root directory of the project run the following command to create the `Docker` image to run:

`docker build --tag cf-proposal .`

In order for sqlite3 databases to persist after shutdown of a docker container, we'll need to create a docker volume:

`docker volume create cf-proposal-db`

Start the application container via the following command:

`docker run --publish 9000:9000 -v cf-proposal-db:/app/sqlite cf-proposal`

Press `Ctrl-C` to stop the container. 


# Assumptions

# Design Decisions

## API Implementation
The API implementation is a fairly simple implementation consisting of the 4 endpoints for the purposes of facilitating the funcitons described in the MVP above. 
- The action associated with redirection sits at the root of the service ("/"). This is to reduce the total length of the URL 
- Actions associated with actions on short urls are prefixed with /url
- Actions associated with retriving statistics are prefixed with /statistics

## Application Layering
The application is split into 4 layers: 
- Controller: Route management and entry point to endpoints.
- Service: Where code related to domain knowledge is performed.
- Repo: Provides an interface to the actions in the persistence layer. 
- Persistence: Directly interacting with the database to manipulate the data model. In this project, this was autogenerated via sqlc.

## Data Model
[Data Dictionary](https://docs.google.com/spreadsheets/d/1lYeBe29FgTnOEaFF-xYTOj10ipwja7ZW6d8-eWqQOho/edit?usp=sharing)
The above linked Google Sheet is a depiction of the data model current in use. As summary of the more notable decisions is as follows:
- **Date fields using TEXT typing**: Sqlite does not have a native date type but the built-in date functions can infer date so long as the string or integer is in the correct format. 
- **Statistics View**: To reduce the code necessary at the service layer, the statistics view aggregates the "entrys" by their defined date conditions. See `statistics.sql` for details on how the statistics are calculated. The service layer just reads from the view for the particular url requested.
- **Expiration Date**: To future proof short urls supporting expiration, an additional field is added to capture a expiration date if desired. 

## Stack
### Golang
Originally, I had intended to do this project in Java using Spring Boot; however, my personal machine was already set up for Go. The rationale I made was, I felt I knew enough in Go to get started, and could look up gap areas where needed - reducing setup time. 

### Sqlite3
Provides a relational db without setup overhead, keeping focus on development of MVP. In addition, allows persistence of data after shutdown as opposed to a pure in memory db solution.  

### sqlc
A Golang code generator which compiles sql. Leveraged this to write out the data model and queries via sql, and save time on writing the persistence layer code. 

### Docker
Leveraging Docker to simplify build environment for those checking out the project.

### Postman
For testing endpoints

### [DB Browser for SQL Lite](https://sqlitebrowser.org/):
Provides a GUI interface to the sqlite database used for development locally. Primary used for debugging and verfication. 

## Trade-offs
1. A validator of some sort will be needed for the UrlDto payload; however, foregoing a validation layer until MVP is achived. Run risk of burning too many hours going into the different permutations for a URL and date. If time allows i'll circle around and add validation there. 
2. Passing database connection as a global variable. Would like to spend more time looking at implementing another pattern, but current implementation is working - will focus on remaining MVP items. 
